scheme NET =
class
  type 
    Net :: stops : Stops
    	   connections : Connections, -- tram nets
    Headway = Time, -- minimum headways
    DrivingTime = Time, -- minimum driving times
    Time = Nat, -- times in number of minutes
    Capacity = Nat, -- capacities
    StopId = Text,  -- names of stops
    Stops = StopId -m-> Capacity,
    Connection :: fromStop : StopId
		  toStop : StopId
    	       	  headway : Headway
		  capacity : Capacity
		  minDrivingTime : DrivingTime,
    Connections = StopId -m-> Connection-set
    
  value /* generators */

    empty_Stops : Stops = [], -- the empty stops

    empty_Connections : Connections = [], -- the empty connection

    empty : Net = mk_Net(empty_Stops, empty_Connections), -- the empty net

    -- insert a stop with a given name and capacity
    insertStop : StopId >< Capacity >< Net -> Net
    insertStop(s, c, n) is mk_Net(stops(n) !! [s +> c], connections(n)),
    
    -- add a connection between given stops, 
    -- with the given minimum headway, capacity and minimum driving time
    addConnection : StopId >< StopId  >< Headway >< Capacity >< DrivingTime >< Net -> Net
    addConnection(s1, s2, h, c, d, n) is
    		      if s1 isin dom(connections(n)) /\ s2 isin dom(connections(n)) then
		      	 mk_Net(stops(n), connections(n) !!
			 		  [s1 +> (connections(n)(s1) union {mk_Connection(s1,s2,h,c,d)})] !!
					  [s2 +> (connections(n)(s2) union {mk_Connection(s2,s1,h,c,d)})])
		      elsif s1 isin dom(connections(n)) /\ s2 ~isin dom(connections(n)) then
			 mk_Net(stops(n), connections(n) !!
					  [s1 +> (connections(n)(s1) union {mk_Connection(s1,s2,h,c,d)})] !!
					  [s2 +> {mk_Connection(s2,s1,h,c,d)}])
		      elsif s1 ~isin dom(connections(n)) /\ s2 isin dom(connections(n)) then
			 mk_Net(stops(n), connections(n) !!
			  		  [s1 +> {mk_Connection(s1,s2,h,c,d)}] !!
					  [s2 +> (connections(n)(s2) union {mk_Connection(s2,s1,h,c,d)})])
		       else
			 mk_Net(stops(n), connections(n) !!
					  [s1 +> {mk_Connection(s1,s2,h,c,d)}] !!
					  [s2 +> {mk_Connection(s2,s1,h,c,d)}]) end

  value /* observers */

    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(s, n) is s isin dom(stops(n)),
 
    -- get the capacity of a stop
    /* TODO: Should we add a precondition for making sure the stop is in the net? It is a partial function, so I guess not. */
    capacity : StopId >< Net -~-> Capacity
    capacity(s, n) is stops(n)(s),

    filterConnections : Connection-set >< StopId -> Connection
    filterConnections(cs, s) is if card(cs) = 1 /\ toStop(hd(cs)) = s then
    			     	   hd(cs)
    			     	else
				   let
					c = hd(cs),
				   	cs' = cs \ {c}
				   in
					if toStop(c) = s then
					   c
					else
					   filterConnections(cs', s)
					end
				   end
				end,

    -- get the connection between two stops
    /* Break down set by recursion */
    /* TODO: Should we add a precondition making sure the stops are in the net? It is a partial function, so I guess not. 
       TODO: Should we add a precondition making sure that s1 and s2 is not the same? */
    getConnection : StopId >< StopId >< Net -~-> Connection
    getConnection(s1, s2, n) is filterConnections(connections(n)(s1), s2),

    hasDirectConnection : StopId >< StopId >< Net -> Bool
    hasDirectConnection(s1, s2, n) is (exists c : Connection :- c isin connections(n)(s1) =>
    			     	       	      fromStop(c) = s1 /\ toStop(c) = s2
    			     	      ),
    
    -- check whether two stops are directly connected in a network
    /* TODO: Should we add a precondition saying that both stops should be in the net? */
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(s1, s2, n) is hasDirectConnection(s1, s2, n) /\ hasDirectConnection(s2, s1, n),

    -- get minimum headway between two connected stops
    /* TODO: Should we add a precondition for making sure the stops and connection are in the net? It is a partial function, so I guess not. */
    minHeadway : StopId >< StopId >< Net -~-> Headway
    minHeadway(s1, s2, n) is headway(getConnection(s1, s2, n)),

    -- get the capacity for a connection between two connected stops
    /* TODO: Should we add a precondition for making sure the stops and connection are in the net? It is a partial function, so I guess not. */
    capacity : StopId >< StopId >< Net -~-> Capacity
    capacity(s1, s2, n) is capacity(getConnection(s1, s2, n)),
 
    -- get minimum driving time between two connected stops
    /* TODO: Should we add a precondition for making sure the stops and connection are in the net? It is a partial function, so I guess not. */
    minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
    minDrivingTime(s1, s2, net) is minDrivingTime(getConnection(s1, s2, net))

    areConnected : StopId >< StopId >< Net -> Bool
    areConnected(s1, s2, n) is let
				cs = connections(n)(s1)


  value /* predicates to check nets */

    isNetConnected : Net -> Bool
    isNetConnected(n) is (all s : StopId :- s isin dom(stops(n)) =>
    		      	      (all s' : StopId :- s' isin dom(stops(n)) /\ s ~= s' =>
    		      	      	   areConnected(s, s', connections(n)(s1), n)
    		      	      )
    		      	 ),

    noDirectSelfConnections : Net -> Bool
    noDirectSelfConnections(n) is (all s : StopId :- s isin dom(stops(n)) =>
    			       	       ~areDirectlyConnected(s,s,n)
				  ),

    hasOneDirectConnection : Net -> Bool
    hasOneDirectConnection(n) is (all cs : Connection-set :- cs isin rng(connections(n)) /\ card(cs) ~= 0 =>
    			      	      card(cs) = 1 \/
    			      	      (all c : Connection :- c isin cs =>
				     	   (all c' : Connection :- c' isin cs /\ c ~= c' => 
    			      	   	     	fromStop(c) = fromStop(c') /\ toStop(c) ~= toStop(c')
					   )
				      )
				  ),

    hasBiDirectConnection : Net -> Bool
    hasBiDirectConnection(n) is (all cs : Connection-set :- cs isin rng(connections(n)) /\ card(cs) ~= 0 =>
    			     	     (all c : Connection :- c isin cs =>
				     	  areDirectlyConnected(fromStop(c), toStop(c), n) /\
				     	  areDirectlyConnected(toStop(c), fromStop(c), n)
				     )
    			     	),


    isWellformed : Net -> Bool
    isWellformed(n) is card(dom(stops(n))) >= 2 /\
    		       isNetConnected(n) /\
    		       noDirectSelfConnections(n) /\
		       hasOneDirectConnection(n) /\
		       hasBiDirectConnection(n)

end  
