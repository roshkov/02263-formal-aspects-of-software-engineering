NET
scheme TIMETABLE = extend NET with
class
  type 
    TimeTable = TramId -m-> TimeSlot-list, -- time tables
    TimeSlot :: stopId 	  : StopId
    	     	arrival   : Time
		departure : Time,
    TramId = Text, -- tram names
    ConId :: from : StopId
    	     to : StopId, -- connection names
    ScheduleSlots :: arrivals   : Time-list
    	       	      	 departures : Time-list,
    --ScheduleTable = ConId -m-> ScheduleSlot-list,
    ScheduleTable = ConId -m-> ScheduleSlots, -- Arrival and departure times. index i in the two lists should correspond to the same connection, i.e. they should not be sorted but ordered.
    StopsTable = StopId -m-> ScheduleSlots

    value /* generators */
      -- the an empty timetable
      empty : TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram : TramId >< TimeTable -> TimeTable
      addTram(tId, tt) is tt !! [tId +> <..>],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop : TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tId, sId, a, d, tt) is tt !! [tId +> tt(tId)^<.mk_TimeSlot(sId, a, d).>],
      /*
      createStopsTable: TimeTable -> read any StopsTable
      createStopsTable(tt) is local
				variable
				    table : StopsTable := [],
				    tIds: TramId-set := dom(tt),
			    	    tId : TramId := hd(tIds)
			      in
				while card(tIds) > 0 do
				    for ts in tt(tId) do
				    	table := table !! [stopId(ts) +> table(stopId(ts))^<.mk_ScheduleSlot(departure(ts), arrival(ts)).>]
			  	    end;
				    tIds := tIds \ {tId};
				    tId := hd(tIds)
				end;
				table
		              end,
      */

	initCreateStopsTable: TimeTable -> StopsTable
	initCreateStopsTable(tt) is createStopsTable(dom(tt), [], tt),

	createStopsTable: Text-set >< StopsTable >< TimeTable -> StopsTable
	createStopsTable(trams, st, tt) is
								if card(trams) = 1 then
									createStopsTableByTimeSlots(tt(hd(trams)), st)
								else
									let
										tram = hd(trams),
										trams' = trams \ {tram}
									in
										createStopsTable(trams', createStopsTableByTimeSlots(tt(tram), st), tt)
									end
								end,
	  					
	createStopsTableByTimeSlots: TimeSlot-list >< StopsTable -> StopsTable
	createStopsTableByTimeSlots(tsl, st) is
											if len(tsl) = 0 then
												st
											elsif len(tsl) = 1 then
												insertTimeSlotInStopsTable(hd(tsl), st)
											else
												let
													ts = hd(tsl),
													tsl' = tl(tsl)
												in
													createStopsTableByTimeSlots(tsl', insertTimeSlotInStopsTable(ts, st))
												end
											end,

	insertTimeSlotInStopsTable: TimeSlot >< StopsTable -> StopsTable
	insertTimeSlotInStopsTable(ts, st) is
										let
											stopId = stopId(ts),
											scheduleSlots = st(stopId) 
										in
											st !! [stopId +> mk_ScheduleSlots(
																	arrivals(scheduleSlots) ^ <.arrival(ts).>,
																	departures(scheduleSlots) ^ <.departure(ts).>
																)]
										end,
	
/*
      createScheduleTable: TimeTable >< TramId -> read any ScheduleTable
      createScheduleTable(tt,tramId) is local
				variable
				    table : ScheduleTable := [],
				    tIds: TramId-set := dom(tt),
				    --tIds : TramId-set := tramIds,
				    --tId : TramId := hd(tIds)
			     	    tId : TramId := tramId
			     in
				while card(tIds) > 0 do
				    for ts in tt(tId) do
				    	if tId isin dom(table) then
					    table := table !! [conId(ts) +> table(conId(ts))^<.mk_ScheduleSlotsList(<.arrival(ts).>,<.departure(ts).>).>]
					else
					    table := table !! [stopId(ts) +> table(stopId(ts))^<.mk_ScheduleSlot(departure(ts), arrival(ts)).>]
					end				    	
			  	    end;
				    tIds := tIds \ {tId};
				    tId := hd(tIds)
				end;
				table
		              end,
*/
      getLargerItems : Time-list >< Time -> Time-list
      getLargerItems(tList, t) is if len(tList) = 0 then
      			       	      <..>
				  elsif len(tList) = 1 /\ hd(tList) > t then
      			       	      <.hd(tList).>
				  elsif hd(tList) > t then
				      <.hd(tList).>^getLargerItems(tl(tList),t)
				  else
				      getLargerItems(tl(tList),t)
				  end,
				  
      getSmallerItems : Time-list >< Time -> Time-list
      getSmallerItems(tList, t) is if len(tList) = 0 then
      			       	      <..>
				   elsif len(tList) = 1 /\ hd(tList) <= t then
      			       	      <.hd(tList).>
				   elsif hd(tList) <= t then
				       <.hd(tList).>^getSmallerItems(tl(tList),t)
				   else
				       getSmallerItems(tl(tList),t)
				   end,

      sort : Time-list -> Time-list
      sort(tList) is if len(tList) <= 1 then
      		       	      tList
			  else
			      sort(getSmallerItems(tl(tList), hd(tList))) ^ <.hd(tList).> ^ sort(getLargerItems(tl(tList), hd(tList)))
			  end,

      findMaxOverlap : Time-list >< Time-list >< Int >< Time -> Int
      findMaxOverlap(sArr, sDep, n, time) is local
					           variable
				    		       --sArr : Time-list := sort(arrival),
				    		       --sDep : Time-list := sort(departure),
				    		       curO : Int 	:= 1,
			    	    		       maxO : Int 	:= 0,
						       t    : Time 	:= time,
						       -- t:Time:=hd(sArr),
						       i    : Int	:= 2,
						       j    : Int	:= 1
			      			   in
						       while i < n /\ j < n do
						       	   if sArr(i) <= sDep(j) then
							       curO := curO + 1;
							       if curO > maxO then
							       	  maxO := curO;
								  t := sArr(i)
							       end;
							       i := i + 1
							   else
							       curO := curO - 1;
							       j := j + 1
							   end
						       end;
						       maxO
		              			   end 
      
  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tId, tt) is tId isin dom(tt),

     --hasOverlap(s1, s2

     --noStopCapacityExceeded : stopsTable >< Net -> Bool
     --noStopCapacityExceeded(stopsTable, n) is,

     --noConnectionCapacityExceeded : ScheduleTable >< Net -> Bool
     --noConnectionCapacityExceeded(scheduleTable, n) is,

     --noHeadwayViolation : ScheduleTable >< Net -> Bool
     --noHeadwayViolation(scheduleTable, n) is,

     noDrivingTimeExceeded : ScheduleTable >< Net -> Bool
     noDrivingTimeExceeded(scheduleTable, n) is (all c : ConId :- c isin dom(scheduleTable) =>
     					     	     (all s : ScheduleSlot :- s isin scheduleTable(c) => -- Maybe elems should be added.
						     	  arrival(s) - departure(s) <= minDrivingTime(from(c), to(c), n)
						     )
     					     	)
						
  --value /* predicates to check time tables */
  /*
     isWellformed : TimeTable >< Net -> Bool
     isWellformed(t, n) is let
				--scheduleTable = createScheduleTable(t),
				--stopsTable = createStopsTable(t)
				
     		     	   in
				--noStopCapacityExceeded(stopsTable,n) /\
     		     	   	--noConnectionCapacityExceeded(scheduleTable, n) /\
			   	--noHeadwayViolation(scheduleTable, n) /\
			   	noDrivingTimeExceeded(scheduleTable, n)
--				true
			   end
			   */
end  
