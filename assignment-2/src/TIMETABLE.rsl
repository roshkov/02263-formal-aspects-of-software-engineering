NET
scheme TIMETABLE = extend NET with
class
  type
    TimeTable = TramId -m-> TimeSlot-list, -- time tables
    TramId = Text, -- tram names
    TimeSlot 	  :: stopId     : StopId
    	     	     arrival    : Time
		     departure  : Time,
    ConId 	  :: from       : StopId
    	     	     to         : StopId, -- connection names
    ScheduleSlots :: arrivals   : Time-list
    	       	     departures : Time-list,
    ScheduleConn = ConId -m-> ScheduleSlots, -- Arrival and departure times. index i in the two lists should correspond to the same connection, i.e. they should not be sorted but ordered.
    StopsTable = StopId -m-> ScheduleSlots

    value /* generators */
      -- the an empty timetable
      empty : TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram : TramId >< TimeTable -> TimeTable
      addTram(tId, tt) is tt !! [tId +> <..>],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop : TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tId, sId, a, d, tt) is tt !! [tId +> tt(tId)^<.mk_TimeSlot(sId, a, d).>],

      createScheduleConn : TimeTable -> ScheduleConn
      createScheduleConn(tt) is createScheduleConnRec(dom(tt), [], tt),

      createScheduleConnRec : TramId-set >< ScheduleConn >< TimeTable -> ScheduleConn
      createScheduleConnRec(trams, st, tt) is if card(trams) = 1 then
                                             createScheduleConnForTram(tt(hd(trams)), st)
                                          else
                                             let
                                                 tram = hd(trams),
                                                 trams' = trams \ {tram}
                                             in
                                                 createScheduleConnRec(trams', createScheduleConnForTram(tt(tram), st), tt)
                                             end
                                          end,

      createScheduleConnForTram : TimeSlot-list >< ScheduleConn -> ScheduleConn
      createScheduleConnForTram(tsl, st) is if len(tsl) < 2 then -- Needs two trains to create an ScheduleSlot
      				       	      	  st
					      elsif len(tsl) = 2 then
					      	  insertScheduleSlot(hd(tsl), hd(tl(tsl)) ,st)
					      else
						  let
						      tsFrom = hd(tsl),
						      tsTo = hd(tl(tsl)),
						      tsl' = tl(tsl) -- Only remove first TimeSlot from the list
						  in
						      createScheduleConnForTram(tsl', insertScheduleSlot(tsFrom, tsTo, st))
						  end
					      end,

      insertScheduleSlot : TimeSlot >< TimeSlot >< ScheduleConn -> ScheduleConn
      insertScheduleSlot(tsFrom, tsTo, st) is let
      				       	          conId = mk_ConId(stopId(tsFrom), stopId(tsTo)),
						  scheduleSlots = st(conId),
						  arr = departure(tsFrom), -- Arrival on connection
						  dep = arrival(tsTo) -- Departure of connection
				    	      in
						  st !! [conId +> mk_ScheduleSlots(arrivals(scheduleSlots) ^ <.arr.>,
						     		          	   departures(scheduleSlots) ^ <.dep.>)]
				              end,

      createStopsTable : TimeTable -> StopsTable
      createStopsTable(tt) is createStopsTableRec(dom(tt), [], tt),

      createStopsTableRec : TramId-set >< StopsTable >< TimeTable -> StopsTable
      createStopsTableRec(trams, st, tt) is if card(trams) = 1 then
				    	     createStopsTableByTimeSlots(tt(hd(trams)), st)
					 else
					     let
					         tram = hd(trams),
					   	 trams' = trams \ {tram}
					     in
						 createStopsTableRec(trams', createStopsTableByTimeSlots(tt(tram), st), tt)
					     end
					 end,

      createStopsTableByTimeSlots : TimeSlot-list >< StopsTable -> StopsTable
      createStopsTableByTimeSlots(tsl, st) is if len(tsl) = 0 then
      				       	      	  st
					      elsif len(tsl) = 1 then
					      	  insertTimeSlotInStopsTable(hd(tsl), st)
					      else
						  let
						      ts = hd(tsl),
						      tsl' = tl(tsl)
						  in
						      createStopsTableByTimeSlots(tsl', insertTimeSlotInStopsTable(ts, st))
						  end
					      end,

      insertTimeSlotInStopsTable : TimeSlot >< StopsTable -> StopsTable
      insertTimeSlotInStopsTable(ts, st) is let
				       	        stopId = stopId(ts),
						scheduleSlots = st(stopId)
					    in
						st !! [stopId +> mk_ScheduleSlots(arrivals(scheduleSlots) ^
						     		   		  <.arrival(ts).>,
						     		   		  departures(scheduleSlots) ^
										  <.departure(ts).>)]
					    end,

      getLargerItems : Time-list >< Time -> Time-list
      getLargerItems(tList, t) is if len(tList) = 0 then
      			       	      <..>
				  elsif len(tList) = 1 /\ hd(tList) > t then
      			       	      <.hd(tList).>
				  elsif hd(tList) > t then
				      <.hd(tList).>^getLargerItems(tl(tList),t)
				  else
				      getLargerItems(tl(tList),t)
				  end,

      getSmallerItems : Time-list >< Time -> Time-list
      getSmallerItems(tList, t) is if len(tList) = 0 then
      			       	      <..>
				   elsif len(tList) = 1 /\ hd(tList) <= t then
      			       	      <.hd(tList).>
				   elsif hd(tList) <= t then
				       <.hd(tList).>^getSmallerItems(tl(tList),t)
				   else
				       getSmallerItems(tl(tList),t)
				   end,
      isSorted : Time-list -> Bool
      isSorted(tList) is (all i : Nat :- i isin inds(tList) =>
     			     (all i' : Nat :- i' isin inds(tList) /\ i < i' =>
			         tList(i) <= tList(i)
			     )
     			 ),

      sort : Time-list -> Time-list
      sort(tList) is if len(tList) <= 1 then
      		       	      tList
			  else
			      sort(getSmallerItems(tl(tList), hd(tList))) ^
			      <.hd(tList).> ^
			      sort(getLargerItems(tl(tList), hd(tList)))
			  end as sortedList
      post isSorted(sortedList),

     findMaxOverlapRec : Time-list >< Time-list >< Int >< Int -> Int
     findMaxOverlapRec(sArr, sDep, curO, maxO) is if len(sArr) > 0 /\ len(sDep) > 0 then
     			  	   	    	         if hd(sArr) <= hd(sDep) then
							     if curO + 1 > maxO then
							         findMaxOverlapRec(tl(sArr), sDep, curO+1, curO+1)
							     else
							         findMaxOverlapRec(tl(sArr), sDep, curO+1, maxO)
							     end
							 else
							     findMaxOverlapRec(sArr, tl(sDep), curO-1, maxO)
							 end
						     else
						         maxO
						     end
     pre isSorted(sArr) /\ isSorted(sDep),

     findMaxOverlap : Time-list >< Time-list -> Int
     findMaxOverlap(arrs, deps) is findMaxOverlapRec(sort(arrs), sort(deps), 0, 0)

  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tId, tt) is tId isin dom(tt),

     noStopCapacityExceeded : StopsTable >< Net -> Bool
     noStopCapacityExceeded(stopsTable, n) is (all sId : StopId :- sId isin dom(stopsTable) =>
     					      	  let
						      arrs = arrivals(stopsTable(sId)),
						      deps = departures(stopsTable(sId))
						  in
						      findMaxOverlap(arrs, deps) <= capacity(sId, n)
						  end
     					      ),

     noConnectionCapacityExceeded : ScheduleConn >< Net -> Bool
     noConnectionCapacityExceeded(scheduleTable, n) is (all c : ConId :- c isin dom(scheduleTable) =>
     						       	    let
								arrs = arrivals(scheduleTable(c)),
								deps = departures(scheduleTable(c))
							    in
								findMaxOverlap(arrs, deps) <= capacity(from(c), to(c), n)
							    end
     						       ),

     noHeadwayViolation : ConId >< Time-list >< Net -> Bool
     noHeadwayViolation(conId, tList, n) is (all i : Nat :- i isin inds(tList) =>
     					        (all i' : Nat :- i' isin inds(tList) /\ i < i' =>
					    	    tList(i') - tList(i) >= minHeadway(from(conId), to(conId),n)
					    	)
     					    )
     pre isSorted(tList),

     noHeadwayViolation : ScheduleConn >< Net -> Bool
     noHeadwayViolation(scheduleTable, n) is (all c : ConId :- c isin dom(scheduleTable) =>
     				       	         noHeadwayViolation(c, sort(departures(scheduleTable(c))),n) /\
						 noHeadwayViolation(c, sort(arrivals(scheduleTable(c))),n)
     				       	     ),

     noDrivingTimeExceeded : ScheduleConn >< Net -> Bool
     noDrivingTimeExceeded(scheduleTable, n) is (all c : ConId :- c isin dom(scheduleTable) =>
						     let
							arrs = arrivals(scheduleTable(c)),
							deps = departures(scheduleTable(c))
						     in
							 (all i : Nat :- i isin inds(arrs) /\ len(arrs) = len(deps) =>
						     	     arrs(i) - deps(i) <= minDrivingTime(from(c), to(c), n)
						     	 )
						     end
     					     	)

  value /* predicates to check time tables */

     isWellformed : TimeTable >< Net -> Bool
     isWellformed(timeTable, n) is let
				       --scheduleTable = createScheduleConn(timeTable),
				       stopsTable = createStopsTable(timeTable)
				   in
				       noStopCapacityExceeded(stopsTable, n) --/\
     		     	   	       --noConnectionCapacityExceeded(scheduleTable, n) /\
			   	       --noHeadwayViolation(scheduleTable, n) /\
			   	       --noDrivingTimeExceeded(scheduleTable, n)
			   	   end

end
